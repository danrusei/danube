[1mdiff --git a/danube-broker/src/broker_server/consumer_handler.rs b/danube-broker/src/broker_server/consumer_handler.rs[m
[1mindex 174de8a..dddc91c 100644[m
[1m--- a/danube-broker/src/broker_server/consumer_handler.rs[m
[1m+++ b/danube-broker/src/broker_server/consumer_handler.rs[m
[36m@@ -38,6 +38,7 @@[m [mimpl ConsumerService for DanubeServerImpl {[m
             }[m
         }[m
 [m
[32m+[m[32m        // checks if the consumer exist and it is connected[m
         match service[m
             .check_if_consumer_exist(&req.consumer_name, &req.subscription, &req.topic_name)[m
             .await[m
[1mdiff --git a/danube-broker/src/broker_service.rs b/danube-broker/src/broker_service.rs[m
[1mindex df43638..ff8b3ab 100644[m
[1m--- a/danube-broker/src/broker_service.rs[m
[1m+++ b/danube-broker/src/broker_service.rs[m
[36m@@ -459,7 +459,7 @@[m [mimpl BrokerService {[m
             None => return None,[m
         };[m
 [m
[31m-        let consumer_id = match subscription.get_consumer_id(consumer_name).await {[m
[32m+[m[32m        let consumer_id = match subscription.validate_consumer(consumer_name).await {[m
             Some(id) => id,[m
             None => return None,[m
         };[m
[1mdiff --git a/danube-broker/src/consumer.rs b/danube-broker/src/consumer.rs[m
[1mindex 0cf90c4..b223ee1 100644[m
[1m--- a/danube-broker/src/consumer.rs[m
[1m+++ b/danube-broker/src/consumer.rs[m
[36m@@ -44,7 +44,7 @@[m [mimpl Consumer {[m
 [m
     // Dispatch a list of entries to the consumer.[m
     pub(crate) async fn send_messages([m
[31m-        &self,[m
[32m+[m[32m        &mut self,[m
         messages: MessageToSend,[m
         _batch_size: usize,[m
     ) -> Result<()> {[m
[36m@@ -54,11 +54,20 @@[m [mimpl Consumer {[m
         // It attempts to send the message through the tx channel.[m
         // If sending fails (e.g., if the client disconnects), it breaks the loop.[m
         if let Some(tx) = &self.tx {[m
[31m-            tx.send(messages).await?;[m
[31m-            trace!("Consumer instace is sending the message over channel");[m
[32m+[m[32m            if let Err(err) = tx.send(messages).await {[m
[32m+[m[32m                // Log the error and handle the channel closure scenario[m
[32m+[m[32m                warn!([m
[32m+[m[32m                    "Failed to send message to consumer with id: {}. Error: {:?}",[m
[32m+[m[32m                    self.consumer_id, err[m
[32m+[m[32m                );[m
[32m+[m
[32m+[m[32m                self.status = false[m
[32m+[m[32m            } else {[m
[32m+[m[32m                trace!("Sending the message over channel to {}", self.consumer_id);[m
[32m+[m[32m            }[m
         } else {[m
             warn!([m
[31m-                "unable to send the message to consumer: {} with id: {}, as the tx is not found",[m
[32m+[m[32m                "Unable to send the message to consumer: {} with id: {}, as the tx is not found",[m
                 self.consumer_name, self.consumer_id[m
             );[m
         };[m
[1mdiff --git a/danube-broker/src/danube_service.rs b/danube-broker/src/danube_service.rs[m
[1mindex 6520ca0..13c5395 100644[m
[1m--- a/danube-broker/src/danube_service.rs[m
[1m+++ b/danube-broker/src/danube_service.rs[m
[36m@@ -24,8 +24,9 @@[m [muse crate::{[m
     broker_server,[m
     broker_service::BrokerService,[m
     metadata_store::{etcd_watch_prefixes, MetaOptions, MetadataStorage, MetadataStore},[m
[31m-    namespace::{DEFAULT_NAMESPACE, SYSTEM_NAMESPACE},[m
[31m-    resources::{Resources, BASE_BROKER_LOAD_PATH, BASE_BROKER_PATH},[m
[32m+[m[32m    resources::{[m
[32m+[m[32m        Resources, BASE_BROKER_LOAD_PATH, BASE_BROKER_PATH, DEFAULT_NAMESPACE, SYSTEM_NAMESPACE,[m
[32m+[m[32m    },[m
     service_configuration::ServiceConfiguration,[m
     topic::SYSTEM_TOPIC,[m
     utils::join_path,[m
[1mdiff --git a/danube-broker/src/dispatcher.rs b/danube-broker/src/dispatcher.rs[m
[1mindex 235ea94..1abcae8 100644[m
[1m--- a/danube-broker/src/dispatcher.rs[m
[1m+++ b/danube-broker/src/dispatcher.rs[m
[36m@@ -48,7 +48,7 @@[m [mimpl Dispatcher {[m
         match self {[m
             Dispatcher::OneConsumer(dispatcher) => Ok(dispatcher.remove_consumer(consumer).await?),[m
             Dispatcher::MultipleConsumers(dispatcher) => {[m
[31m-                Ok(dispatcher.remove_consumer(consumer).await?)[m
[32m+[m[32m                Ok(dispatcher.remove_consumer(consumer.consumer_id).await?)[m
             }[m
         }[m
     }[m
[1mdiff --git a/danube-broker/src/dispatcher/dispatcher_multiple_consumers.rs b/danube-broker/src/dispatcher/dispatcher_multiple_consumers.rs[m
[1mindex 5ba4554..6c09c32 100644[m
[1m--- a/danube-broker/src/dispatcher/dispatcher_multiple_consumers.rs[m
[1m+++ b/danube-broker/src/dispatcher/dispatcher_multiple_consumers.rs[m
[36m@@ -7,19 +7,14 @@[m [muse tracing::trace;[m
 use crate::consumer::{Consumer, MessageToSend};[m
 [m
 #[derive(Debug)][m
[31m-#[allow(dead_code)][m
 pub(crate) struct DispatcherMultipleConsumers {[m
[31m-    topic_name: String,[m
[31m-    subscription_name: String,[m
     consumers: Vec<Arc<Mutex<Consumer>>>,[m
     index_consumer: AtomicUsize,[m
 }[m
 [m
 impl DispatcherMultipleConsumers {[m
[31m-    pub(crate) fn new(topic_name: &str, subscription_name: &str) -> Self {[m
[32m+[m[32m    pub(crate) fn new() -> Self {[m
         DispatcherMultipleConsumers {[m
[31m-            topic_name: topic_name.into(),[m
[31m-            subscription_name: subscription_name.into(),[m
             consumers: Vec::new(),[m
             index_consumer: AtomicUsize::new(0),[m
         }[m
[36m@@ -34,13 +29,13 @@[m [mimpl DispatcherMultipleConsumers {[m
     }[m
 [m
     // manage the removal of consumers from the dispatcher[m
[31m-    #[allow(dead_code)][m
[31m-    pub(crate) async fn remove_consumer(&mut self, consumer: Consumer) -> Result<()> {[m
[32m+[m[32m    pub(crate) async fn remove_consumer(&mut self, consumer_id: u64) -> Result<()> {[m
         // Find the position asynchronously[m
         let pos = {[m
             let mut pos = None;[m
             for (index, x) in self.consumers.iter().enumerate() {[m
[31m-                if x.lock().await.consumer_id == consumer.consumer_id {[m
[32m+[m[32m                let consumer = x.lock().await;[m
[32m+[m[32m                if consumer.consumer_id == consumer_id {[m
                     pos = Some(index);[m
                     break;[m
                 }[m
[36m@@ -95,15 +90,26 @@[m [mimpl DispatcherMultipleConsumers {[m
     }[m
 [m
     pub(crate) async fn send_messages(&self, messages: MessageToSend) -> Result<()> {[m
[31m-        // maybe wrap Vec<8> into a generic Message[m
         // selects the next available consumer based on available permits[m
         let consumer = self.get_next_consumer()?;[m
[31m-        let consumer = consumer.lock().await;[m
[32m+[m[32m        let mut consumer_guard = consumer.lock().await;[m
         let batch_size = 1; // to be calculated[m
[31m-        consumer.send_messages(messages, batch_size).await?;[m
[32m+[m
[32m+[m[32m        // check if the consumer is active, if not remove from the dispatcher[m
[32m+[m[32m        if !consumer_guard.status {[m
[32m+[m[32m            // can't be removed for now, as it force alot of functions to be moved to mutable[m
[32m+[m[32m            // maybe use an backgroud process that remove unused resources[m
[32m+[m[32m            // like disconnected consumers and producers[m
[32m+[m[32m            // or maybe move to Arc<Mutex<Vec<Consumer>>> ??[m
[32m+[m[32m            //return self.remove_consumer(consumer_guard.consumer_id).await;[m
[32m+[m
[32m+[m[32m            return Ok(());[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        consumer_guard.send_messages(messages, batch_size).await?;[m
         trace!([m
             "Dispatcher is sending the message to consumer: {}",[m
[31m-            consumer.consumer_id[m
[32m+[m[32m            consumer_guard.consumer_id[m
         );[m
         Ok(())[m
     }[m
[1mdiff --git a/danube-broker/src/dispatcher/dispatcher_single_consumer.rs b/danube-broker/src/dispatcher/dispatcher_single_consumer.rs[m
[1mindex e82f91c..4e50ce8 100644[m
[1m--- a/danube-broker/src/dispatcher/dispatcher_single_consumer.rs[m
[1m+++ b/danube-broker/src/dispatcher/dispatcher_single_consumer.rs[m
[36m@@ -6,27 +6,16 @@[m [muse tracing::{info, warn};[m
 use crate::consumer::{Consumer, MessageToSend};[m
 [m
 #[derive(Debug)][m
[31m-#[allow(dead_code)][m
 pub(crate) struct DispatcherSingleConsumer {[m
[31m-    topic_name: String,[m
[31m-    subscription_name: String,[m
[31m-    subscription_type: i32, // should be SubscriptionType,[m
     consumers: Vec<Arc<Mutex<Consumer>>>,[m
     active_consumer: Option<Arc<Mutex<Consumer>>>,[m
 }[m
 [m
 impl DispatcherSingleConsumer {[m
[31m-    pub(crate) fn new([m
[31m-        topic_name: impl Into<String>,[m
[31m-        subscription_name: impl Into<String>,[m
[31m-        subscription_type: i32, // should be SubscriptionType,[m
[31m-    ) -> Self {[m
[32m+[m[32m    pub(crate) fn new() -> Self {[m
         DispatcherSingleConsumer {[m
[31m-            topic_name: topic_name.into(),[m
[31m-            subscription_name: subscription_name.into(),[m
[31m-            subscription_type,[m
[31m-            active_consumer: None,[m
             consumers: Vec::new(),[m
[32m+[m[32m            active_consumer: None,[m
         }[m
     }[m
 [m
[36m@@ -68,11 +57,20 @@[m [mimpl DispatcherSingleConsumer {[m
 [m
         // maybe wrap Vec<Bytes> into a generic Message[m
 [m
[31m-        current_consumer[m
[31m-            .lock()[m
[31m-            .await[m
[31m-            .send_messages(messages, 1)[m
[31m-            .await?;[m
[32m+[m[32m        let mut consumer_guard = current_consumer.lock().await;[m
[32m+[m
[32m+[m[32m        // check if the consumer is active, if not remove from the dispatcher[m
[32m+[m[32m        if !consumer_guard.status {[m
[32m+[m[32m            // can't be removed for now, as it force alot of functions to be moved to mutable[m
[32m+[m[32m            // maybe use an backgroud process that remove unused resources[m
[32m+[m[32m            // like disconnected consumers and producers[m
[32m+[m[32m            // or maybe move to Arc<Mutex<Vec<Consumer>>> ??[m
[32m+[m[32m            //return self.remove_consumer(consumer_guard.consumer_id).await;[m
[32m+[m
[32m+[m[32m            return Ok(());[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        consumer_guard.send_messages(messages, 1).await?;[m
 [m
         Ok(())[m
     }[m
[1mdiff --git a/danube-broker/src/main.rs b/danube-broker/src/main.rs[m
[1mindex 30073fd..8ef635b 100644[m
[1m--- a/danube-broker/src/main.rs[m
[1m+++ b/danube-broker/src/main.rs[m
[36m@@ -6,7 +6,6 @@[m [mmod danube_service;[m
 mod dispatcher;[m
 mod error_message;[m
 mod metadata_store;[m
[31m-mod namespace;[m
 mod policies;[m
 mod producer;[m
 mod resources;[m
[1mdiff --git a/danube-broker/src/namespace.rs b/danube-broker/src/namespace.rs[m
[1mdeleted file mode 100644[m
[1mindex 7195d3f..0000000[m
[1m--- a/danube-broker/src/namespace.rs[m
[1m+++ /dev/null[m
[36m@@ -1,39 +0,0 @@[m
[31m-use anyhow::Result;[m
[31m-[m
[31m-pub(crate) static DEFAULT_NAMESPACE: &str = "default";[m
[31m-pub(crate) static SYSTEM_NAMESPACE: &str = "system";[m
[31m-[m
[31m-// NameSpace - coordinates topics ownership[m
[31m-#[derive(Debug, Default)][m
[31m-#[allow(dead_code)][m
[31m-pub(crate) struct NameSpace {[m
[31m-    name: String,[m
[31m-    // list of topic_name associated with the Namespace[m
[31m-    topics: Vec<String>,[m
[31m-}[m
[31m-[m
[31m-impl NameSpace {[m
[31m-    // Setting up predefined namespaces during the initialization phase of the Danube service.[m
[31m-    #[allow(dead_code)][m
[31m-    pub(crate) fn register_bootstrap_namespaces() -> Result<()> {[m
[31m-        todo!()[m
[31m-    }[m
[31m-[m
[31m-    // Checks whether a topic exists within the specified namespace[m
[31m-    #[allow(dead_code)][m
[31m-    pub(crate) fn check_topic_exist(&self, topic_name: &str) -> bool {[m
[31m-        self.topics.contains(&topic_name.to_owned())[m
[31m-    }[m
[31m-[m
[31m-    // Retrieves the list of topics within the specified namespace[m
[31m-    #[allow(dead_code)][m
[31m-    pub(crate) fn get_list_of_topics(&self, _namespace_name: &str) -> Vec<String> {[m
[31m-        self.topics.clone()[m
[31m-    }[m
[31m-[m
[31m-    // Retrieves the list of all partitions within the specified namespace[m
[31m-    #[allow(dead_code)][m
[31m-    pub(crate) fn get_all_partitions(&self, _namespace_name: &str) -> Vec<String> {[m
[31m-        self.topics.clone()[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/danube-broker/src/resources.rs b/danube-broker/src/resources.rs[m
[1mindex 5bb1644..5247dc9 100644[m
[1m--- a/danube-broker/src/resources.rs[m
[1m+++ b/danube-broker/src/resources.rs[m
[36m@@ -29,6 +29,9 @@[m [mpub(crate) static LOADBALANCE_DECISION_PATH: &str = "/cluster/load_balance";[m
 // Cluster Leader broker_id, posted by Leader Election Service[m
 pub(crate) static LEADER_ELECTION_PATH: &str = "/cluster/leader";[m
 [m
[32m+[m[32mpub(crate) static DEFAULT_NAMESPACE: &str = "default";[m
[32m+[m[32mpub(crate) static SYSTEM_NAMESPACE: &str = "system";[m
[32m+[m
 // Resources provides the mechanisms to store and retrieve specific information from MetadataStore[m
 //[m
 // The docs/internal_resources.md document describe how the resources are organized in Metadata Store[m
[1mdiff --git a/danube-broker/src/subscription.rs b/danube-broker/src/subscription.rs[m
[1mindex 6fc37f6..cae60e6 100644[m
[1m--- a/danube-broker/src/subscription.rs[m
[1m+++ b/danube-broker/src/subscription.rs[m
[36m@@ -16,7 +16,6 @@[m [muse crate::{[m
 // They also handle dispatchers that manage the distribution of messages to these consumers.[m
 #[derive(Debug)][m
 pub(crate) struct Subscription {[m
[31m-    pub(crate) topic_name: String,[m
     pub(crate) subscription_name: String,[m
     pub(crate) subscription_type: i32,[m
     // the consumers registered to the subscription, consumer_id -> Consumer[m
[36m@@ -35,12 +34,10 @@[m [mpub(crate) struct SubscriptionOptions {[m
 impl Subscription {[m
     // create new subscription[m
     pub(crate) fn new([m
[31m-        topic_name: &str,[m
         sub_options: SubscriptionOptions,[m
         _meta_properties: HashMap<String, String>,[m
     ) -> Self {[m
         Subscription {[m
[31m-            topic_name: topic_name.into(),[m
             subscription_name: sub_options.subscription_name,[m
             subscription_type: sub_options.subscription_type,[m
             consumers: HashMap::new(),[m
[36m@@ -65,24 +62,13 @@[m [mimpl Subscription {[m
         } else {[m
             let new_dispatcher = match subscription_type {[m
                 // Exclusive[m
[31m-                0 => Dispatcher::OneConsumer(DispatcherSingleConsumer::new([m
[31m-                    &self.topic_name,[m
[31m-                    &self.subscription_name,[m
[31m-                    0,[m
[31m-                )),[m
[32m+[m[32m                0 => Dispatcher::OneConsumer(DispatcherSingleConsumer::new()),[m
 [m
                 // Shared[m
[31m-                1 => Dispatcher::MultipleConsumers(DispatcherMultipleConsumers::new([m
[31m-                    &self.topic_name,[m
[31m-                    &self.subscription_name,[m
[31m-                )),[m
[32m+[m[32m                1 => Dispatcher::MultipleConsumers(DispatcherMultipleConsumers::new()),[m
 [m
                 // Failover[m
[31m-                2 => Dispatcher::OneConsumer(DispatcherSingleConsumer::new([m
[31m-                    &self.topic_name,[m
[31m-                    &self.subscription_name,[m
[31m-                    2,[m
[31m-                )),[m
[32m+[m[32m                2 => Dispatcher::OneConsumer(DispatcherSingleConsumer::new()),[m
 [m
                 _ => {[m
                     return Err(anyhow!("Should not get here"));[m
[36m@@ -141,11 +127,19 @@[m [mimpl Subscription {[m
         todo!()[m
     }[m
 [m
[31m-    // Get Consumer - returns consumer ID[m
[31m-    pub(crate) async fn get_consumer_id(&self, consumer_name: &str) -> Option<u64> {[m
[32m+[m[32m    // Validate Consumer - returns consumer ID[m
[32m+[m[32m    pub(crate) async fn validate_consumer(&self, consumer_name: &str) -> Option<u64> {[m
         for consumer in self.consumers.values() {[m
[31m-            if consumer.lock().await.consumer_name == consumer_name {[m
[31m-                return Some(consumer.lock().await.consumer_id);[m
[32m+[m[32m            let mut consumer_guard = consumer.lock().await;[m
[32m+[m
[32m+[m[32m            if consumer_guard.consumer_name == consumer_name {[m
[32m+[m[32m                // if consumer exist and its status is false, then the consumer has disconnected[m
[32m+[m[32m                // the consumer client may try to reconnect[m
[32m+[m[32m                // then set the status to true and use the consumer[m
[32m+[m[32m                if !consumer_guard.status {[m
[32m+[m[32m                    consumer_guard.status = true[m
[32m+[m[32m                }[m
[32m+[m[32m                return Some(consumer_guard.consumer_id);[m
             }[m
         }[m
         None[m
[1mdiff --git a/danube-broker/src/topic.rs b/danube-broker/src/topic.rs[m
[1mindex f2fe2af..9bd1831 100644[m
[1m--- a/danube-broker/src/topic.rs[m
[1m+++ b/danube-broker/src/topic.rs[m
[36m@@ -175,7 +175,7 @@[m [mimpl Topic {[m
         let subscription = self[m
             .subscriptions[m
             .entry(options.subscription_name.clone())[m
[31m-            .or_insert(Subscription::new(topic_name, options.clone(), sub_metadata));[m
[32m+[m[32m            .or_insert(Subscription::new(options.clone(), sub_metadata));[m
 [m
         if subscription.is_exclusive() && !subscription.get_consumers().is_empty() {[m
             warn!("Not allowed to add the Consumer: {}, the Exclusive subscription can't be shared with other consumers", options.consumer_name);[m
